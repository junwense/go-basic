#针对于topn的这个问题很经典，这个问题主要是关注以下几个细节
1。计算的时间范围（比如要多久计算出来）
2。计算的数据的数据量
3。是否是实时计算
4。同一时间需要计算的量

第一个问题比较简单，举几个具体的场景
1。计算某公司t+1的业务排行榜（离线计算）
    这种场景时间范围就很长，一般是设计为异步的计算，通过晚间处理好昨日的数据放在缓存里面，然后上游系统获取的时候直接从缓存获取数据，
但是这里对数据的生成时间是有要求的，比如昨日系统的数据量特别大，有上游在00：01分的时候访问排行榜，这个时候，可能会访问到昨日的数据或者说是兜底的数据
这种都是业务方的设计，一般这种在约定时间内生成数据就不会有问题。但是如果数据量大，可以考虑在11：30的时候进行数据的加载和缓存生成，把数据
读取出来放到redis的zset里面进行排序，然后过滤
2。计算某内容生产平台某评论的排行，每分钟加载一次，并且按照评论的数量展示（实时）
    评论的排行设计一般是用于评论查询的时候展示的，一般是在评论到一定热度（比如点赞数量过100，子评论数量过100）这个时候会开启评论排序，
默认排序是直接按照时间排序的，然后数据直接放到zset里面进行排序即可。但是这里要考虑的是同一时间计算的数据量很大，而且计算的数据访问量也很大的问题，这里可以采取
消息队列写评论，异步写评论可以控制写流量，牺牲一定的实时性，这样计算排行榜只要根据写流量来计算即可，然后做好写流量的数据隔离和限流，如果是对于爆点热评，
可以考虑使用单独的redis集群来处理这些排行榜。
3。计算网站api的访问次数
    这个是近实时计算，是程序内部采集数据然后批量上报计算，这种一般是定时任务定时检查数据，然后在很小的一个时间周期内写入到缓存里面。

详细方案设计
本地缓存+redis缓存+一致性hash （redis可以进行拆分，搞一个静态redis机器，只用于榜单数据的保存）
这里计算缓存可以考虑抽象出一个榜单服务
接口设计可以如下
addRank
getRank
然后在设置一个定时任务，检查点赞数量到一定的作品，然后调用addRank发起排序，这个时候榜单服务就会对这个数据进行排序。
业务方需要获取排行榜数据使用getRank，就可以拿到此Rank的数据。
这个时候，要让业务方访问到榜单服务进行一致性hash，即访问到某台固定到机器上，然后此机器开启本地缓存，同时写入一份默认数据。

然后榜单访问业务方所需要计算到数据，定时计算数据数据写入redis，然后某台机器则定时访问redis拉取最新数据更新缓存。

榜单服务需要维护一个榜单对应机器到列表，同时检测这些机器是否宕机，如果宕机，需要重启机器
如果机器宕机，这个时候榜单访问到是什么数据呢？数据可以放到cdn上进行缓存一份，然后cdn先兜底。
如果数据真的访问到本地缓存，但是本地缓存没有，或者被淘汰了怎么办，这里可以找redis取数据，看下redis里有没有，但是要做好
限流和熔断，也可以直接返回默认数据，或者说redis集群可以做拆分，直接访问静态redis拿到数据。

缓存一致性问题需要考虑么？不需要，因为数据都是榜单服务到一个服务来计算数据，不存在并发写问题。在机器宕机到情况下，可能会出现。

这里要注意控制本地缓存用量，本地缓存也是采用和redis计算榜单的一样排序方式，然后还要加入最近最少访问的方式进行淘汰数据。
redis缓存的计算如果在计算数据量过大的情况，可以直接通过另一个服务集群来计算，计算完成后写入redis。

最后，redis zset计算榜单如果生成过慢怎么办，这里2个瓶颈，
一个是计算所需要的数据量太大，查询太慢，这个时候只能通过加db的读节点解决。
一个是计算的数据量内存放不下，这个时候只能把数据进行拆分做mapreduce的处理，但是拆分会有数据不一致的问题，数据读取出来计算的过程中变化来就会不一致
